<context>
# Overview  
Claimy is an Agentic AI Claims Platform that leverages multi-agent systems powered by foundation models (GPT-4.1, GPT-4o) to automate and augment the end-to-end processing of insurance claims. This Proof of Concept explores cutting-edge agentic AI architectures where autonomous agents collaborate to deliver instant, explainable claim recommendations, intelligent email generation, and real-time operational insights—reducing average resolution time to seconds while preserving regulatory compliance and customer trust.

Unlike traditional single-model AI systems, Claimy employs a multi-agent architecture where specialized AI agents work collaboratively:
- Assessment Agent: Analyzes claims using foundation models for decision-making
- Communication Agent: Generates personalized customer communications
- Orchestrator Agent: Coordinates workflow between specialized agents
- Compliance Agent: Ensures regulatory adherence and audit trails
- Learning Agent: Captures feedback and improves system performance

This agentic approach enables more robust, explainable, and scalable claim processing compared to monolithic AI systems.

# Core Features  
## Multi-Agent Assessment System
- **Orchestrator Agent**: Coordinates claim processing workflow between specialized agents using GPT-4.1/GPT-4o
- **Assessment Agent**: Generate Approve/Reject/Human Review with confidence score using foundation models
- **Reasoning Agent**: Display explainable rationale with bullet checklist (policy coverage, document completeness, timeline consistency)
- **Document Agent**: Identify and highlight missing artifacts using multimodal capabilities
- **Feedback Agent**: Capture agent override decisions and human feedback for continuous learning
- **Audit Agent**: Log all agent decisions, rationale, and interactions in compliance audit table

## Claims Inbox & Dashboard
- Table of tickets with AI Recommendation, Human Feedback, Submission Date
- KPI tiles (Automation Rate, Avg. Resolution Time, Decision Accuracy) with trend analysis
- Filters: status, date range, agent, model version
- Drill-down to Claim Details and Communication history

# User Experience  
## User Personas
- **Claims Handling Agent**: Needs accurate AI recommendations, one-click email drafts, audit trail
- **Claims Team Manager**: Requires dashboard of automation rate & accuracy, override controls
- **End Customer (Claimant)**: Wants fast, fair decision, clear requests for docs
- **Compliance Officer**: Needs explainability, data privacy, SOC2/GDPR adherence
- **ML Ops / Data Scientist**: Requires feedback signals, model version control, monitoring

## Key User Flows
1. Claims Agent sees AI "Approve/Reject/Needs Review" suggestion with validation checklist for quick verification
2. Claims Agent uses AI to draft personalized email requesting missing documents with minimal edits
3. Manager views real-time KPIs (automation rate, resolution time, accuracy) to spot bottlenecks
4. Agent provides thumbs-up/down feedback on AI decisions for future improvement
5. Compliance Officer accesses stored explanations and data sources for due diligence

## UI/UX Considerations
- Real-time agent transparency with live conversation displays
- Human-centric design with clear intervention points
- Explainable AI interfaces with expandable reasoning panels
- Modular shadcn/ui components for customizable demonstrations
- Stakeholder-specific dashboard views for different user types
</context>

<PRD>
# Technical Architecture  
## Technology Stack
- **Agentic Framework**: AutoGen 0.6.1 (2025) - Latest AG2/AutoGen with AgentChat, Teams, Human-in-the-Loop, and advanced multi-agent orchestration capabilities
- **LLM Provider**: Azure OpenAI Latest API - Enterprise-grade security, compliance, data residency, and consistent API access to GPT-4.1/GPT-4o
- **Backend Framework**: FastAPI 0.115.12 (2025) - High-performance async Python framework, automatic OpenAPI docs, excellent for AI/ML workloads with WebSocket support
- **Frontend Framework**: Next.js 15.0+ (2024) - React 19 support, App Router, Server Components, optimal for complex dashboards and real-time agent interactions
- **UI Component System**: shadcn/ui Latest (2024) - Copy-paste component system with full customization control, built on Radix UI primitives for accessibility

## System Components
### Frontend Layer (Next.js 15 + shadcn/ui)
- Next.js 15 App Router with React 19 support
- shadcn/ui Components for modular, customizable UI
- Real-time Agent Dashboard for monitoring multiple agents
- Explainability Interface for decision transparency
- Human Intervention UI for oversight controls

### Backend Layer (FastAPI)
- FastAPI 0.104+ Server with async performance
- WebSocket Agent Streams for real-time communication
- REST API Endpoints for standard operations
- Background Tasks for long-running agent processes

### Multi-Agent Framework (AutoGen 0.6.1)
- **AgentChat Teams**: RoundRobinGroupChat, SelectorGroupChat, and Swarm patterns for agent coordination
- **GraphFlow (Workflows)**: DiGraphBuilder for structured execution with sequential, parallel, conditional, and looping behaviors
- **UserProxyAgent**: Built-in human-in-the-loop integration with custom input functions for WebSocket/FastAPI integration
- **Specialized Agents**: AssistantAgent, ConversableAgent with tool calling and handoff capabilities
- **Termination Conditions**: TextMentionTermination, HandoffTermination, and max_turns for conversation control
- **State Management**: Built-in conversation persistence, save/load capabilities for session management
- **Real-time Streaming**: run_stream() method for live agent interactions and WebSocket integration

### Azure OpenAI Services
- GPT-4o and GPT-4.1 foundation models
- Azure OpenAI Embeddings for RAG capabilities
- Content Safety for moderation
- Enterprise security and compliance features

## Data Models
- Claims Database for core claim information
- Policy Knowledge Base for decision rules
- Vector Database for RAG capabilities
- AutoGen Conversation History for agent interactions
- Agent Decision Audit Trail for compliance

## APIs and Integrations
- Azure OpenAI API for foundation model access
- AutoGen framework APIs for agent coordination
- WebSocket APIs for real-time agent communication
- REST APIs for standard CRUD operations
- Integration endpoints for existing insurance systems

## Infrastructure Requirements
- Cloud hosting for PoC deployment
- Vector database for RAG and agent memory storage
- WebSocket infrastructure for real-time agent communication
- Basic monitoring and logging for agent health tracking
- Simple backup for conversation history and agent state

## Installation & Setup
- Install AutoGen: `uv add "autogen-agentchat"`
- Install OpenAI integration: `uv add "autogen-ext[openai]"`
- **Backend/Frontend Boilerplate**: Already provided and configured
- **Azure OpenAI Configuration**: Pre-configured in .env file with:
  - AZURE_OPENAI_API_KEY
  - AZURE_OPENAI_ENDPOINT  
  - AZURE_OPENAI_API_VERSION
  - AZURE_OPENAI_DEPLOYMENT_NAME

# Development Roadmap  
## Phase 1: Foundation & Core Agent Development (MVP)
**Scope**: Basic multi-agent system with structured workflow control

### Research & Planning (Week 1)
- **Research AutoGen GraphFlow patterns** for insurance claim processing workflows
- **Analyze existing claim processing steps** to identify optimal agent handoff points
- **Design minimal viable workflow** that demonstrates clear value with 2-3 agents maximum
- **Create demonstration script** showing before/after scenarios for stakeholder presentations
- **Plan integration approach** with existing FastAPI/Next.js boilerplate

### Development & Implementation (Weeks 2-4)
- Integrate AutoGen framework with existing backend boilerplate
- **Implement GraphFlow workflow** using DiGraphBuilder for structured claim processing
- Create Assessment Agent with Azure OpenAI GPT-4o integration
- Create Communication Agent for email drafts
- **Design sequential workflow**: Claim Intake → Assessment → Communication → Human Review
- Enhance existing FastAPI backend with AutoGen WebSocket support
- Develop agent interfaces using existing Next.js/shadcn/ui frontend
- **Add workflow visualization** showing agent execution paths and decision points
- Create simple dashboard for agent monitoring with workflow status

**Deliverables**: Working GraphFlow-based multi-agent system with structured, explainable workflows + demonstration plan

## Phase 2: Enhanced Agent Capabilities & UI
**Scope**: Advanced agent features with parallel and conditional workflows

### Research & Planning (Week 1)
- **Research parallel processing patterns** in AutoGen for simultaneous claim analysis tasks
- **Study conditional workflow examples** to design claim complexity routing logic
- **Analyze human intervention best practices** for maintaining trust and control
- **Design advanced demonstration scenarios** showcasing parallel processing and conditional logic
- **Plan UI/UX for workflow visualization** that clearly shows agent collaboration

### Development & Implementation (Weeks 2-6)
- **Implement parallel GraphFlow patterns** for simultaneous document analysis and policy checking
- Add Reasoning Agent with explainable decision-making
- Implement Document Agent for missing artifact detection
- **Create conditional workflow branches** based on claim complexity and risk assessment
- Enhance Communication Agent with multi-language support
- Build comprehensive agent dashboard with real-time workflow visualization
- **Add human intervention nodes** in GraphFlow for oversight and override capabilities
- Implement feedback collection system integrated with workflow completion
- Create detailed explainability interfaces showing workflow execution paths

**Deliverables**: Advanced GraphFlow system with parallel processing, conditional logic, comprehensive explainability + advanced demonstration scenarios

## Phase 3: Learning & Optimization Systems
**Scope**: Continuous improvement and advanced analytics

### Research & Planning (Week 1)
- **Research feedback loop patterns** in multi-agent systems for continuous learning
- **Study analytics and monitoring approaches** for agent performance optimization
- **Analyze compliance requirements** for audit trails and regulatory reporting
- **Design comprehensive demonstration strategy** showing system evolution and learning
- **Plan stakeholder presentation materials** highlighting ROI and business impact

### Development & Implementation (Weeks 2-6)
- Implement Feedback Agent for learning from human input
- Add Analytics Agent for performance tracking
- Build Optimization Agent for system improvement
- Create advanced monitoring and alerting systems
- Implement agent performance dashboards
- Add compliance and audit trail features
- Develop export capabilities for presentations

**Deliverables**: Self-improving system with comprehensive analytics, compliance features + complete demonstration package for stakeholder presentations

## Phase 4: Production Readiness & Scale (CANCELLED - Beyond PoC Scope)
**Note**: This phase is cancelled as it goes beyond the Proof of Concept scope. The PoC will conclude after Phase 3 with a comprehensive demonstration system.

# Logical Dependency Chain
## Foundation First (Phase 1)
1. **AutoGen Framework Integration** - Integrate with existing backend boilerplate
2. **Azure OpenAI Integration** - Leverage pre-configured .env settings for all agent functionality
3. **Enhanced Backend** - Add AutoGen capabilities to existing FastAPI structure
4. **Core Agent Development** - Orchestrator and Assessment agents are foundational
5. **Frontend Integration** - Connect existing Next.js/shadcn/ui frontend to agents
6. **Basic Workflow** - End-to-end claim processing to prove concept

## Rapid Usability (Phase 2)
1. **Enhanced UI Components** - Build on shadcn/ui foundation for better UX
2. **Real-time Communication** - WebSocket integration for live agent monitoring
3. **Explainability Features** - Critical for stakeholder buy-in and trust
4. **Human Intervention** - Essential for practical deployment and safety
5. **Advanced Agents** - Reasoning and Document agents add significant value
6. **Feedback Systems** - Enable continuous improvement from day one

## Scalable Foundation (Phase 3)
1. **Learning Systems** - Build on feedback collection to enable improvement
2. **Analytics Infrastructure** - Monitor and optimize agent performance
3. **Compliance Features** - Audit trails and regulatory compliance
4. **Advanced Monitoring** - Comprehensive system health and performance tracking
5. **Export Capabilities** - Enable stakeholder presentations and reporting

# Risks and Mitigations  
## Technical Challenges
**Risk**: Agent coordination failures leading to inconsistent decisions
**Mitigation**: Robust orchestrator agent + fallback to human review + comprehensive testing

**Risk**: Foundation model hallucinations in multi-agent interactions
**Mitigation**: Cross-agent validation + confidence scoring + guardrails + human oversight

**Risk**: Agent communication loops causing system deadlocks
**Mitigation**: Timeout mechanisms + circuit breakers + monitoring + kill switches

**Risk**: Foundation model API dependencies causing system failures
**Mitigation**: Multi-provider fallbacks + local model alternatives + graceful degradation

## MVP Definition and Scope
**Risk**: Over-engineering the initial MVP leading to delayed delivery
**Mitigation**: Focus on core claim processing workflow with minimal viable agents (Orchestrator + Assessment + Communication)

**Risk**: Insufficient demonstration value for stakeholders
**Mitigation**: Prioritize explainability features and real-time transparency in Phase 1

**Risk**: Technical complexity overwhelming development timeline
**Mitigation**: Use proven frameworks (AutoGen, FastAPI, Next.js) with extensive documentation and community support

## Resource Constraints
**Risk**: Limited expertise in multi-agent systems
**Mitigation**: Leverage AutoGen's built-in patterns + extensive documentation + community resources

**Risk**: Azure OpenAI API costs during development
**Mitigation**: Implement rate limiting + cost monitoring + efficient prompt engineering + development quotas

**Risk**: Integration complexity with existing systems
**Mitigation**: Start with standalone PoC + plan integration points early + use standard APIs

## Adoption and Trust
**Risk**: User resistance to complex multi-agent systems
**Mitigation**: Transparent agent decision trees + explainable AI + gradual rollout + comprehensive training

**Risk**: Regulatory compliance concerns
**Mitigation**: Built-in audit trails + compliance-first design + legal review at each phase

**Risk**: Performance degradation over time
**Mitigation**: Continuous monitoring + performance baselines + automated alerts + regular optimization

# Appendix  
## Success Metrics
- Increase straight-through automation from 85.5% to 90%
- Improve decision accuracy from 75.5% to ≥85%
- Achieve ≥80% claims with human feedback
- Improve customer NPS by +10 points
- Demonstrate effective multi-agent collaboration and explainability

## Non-Functional Requirements
- Reliability: 99% uptime for PoC demonstrations
- Explainability: Store rationale + source documents, accessible via API
- Real-time Responsiveness: WebSocket streaming for live agent interactions

## Agentic AI Glossary
- **Agentic AI**: AI systems that can act autonomously, make decisions, and perform tasks with minimal human intervention
- **Multi-Agent System (MAS)**: A system composed of multiple autonomous agents that interact and collaborate to solve complex problems
- **Agent Orchestration**: The coordination and management of multiple AI agents working together
- **Foundation Models**: Large pre-trained models (like GPT-4.1, GPT-4o) used as the base for agent capabilities
- **Human-in-the-Loop (HITL)**: Integration of human oversight and intervention in agent decision-making processes

## Open Questions
1. What is the optimal agent communication protocol for claim processing workflows?
2. How should agent disagreements be resolved when multiple agents provide conflicting recommendations?
3. Should we use GPT-4.1 vs GPT-4o for different agent roles, or standardize on one model?
4. What level of human oversight is required for different agent decisions?
5. How will multi-agent decision trails be reported to regulators?

## Reference Materials
- [AutoGen 0.6.1 AgentChat Documentation](https://microsoft.github.io/autogen/stable/user-guide/agentchat-user-guide/tutorial/index.html)
- [AutoGen Human-in-the-Loop Guide](https://microsoft.github.io/autogen/stable/user-guide/agentchat-user-guide/tutorial/human-in-the-loop.html)
- [AutoGen GraphFlow (Workflows) Guide](https://microsoft.github.io/autogen/stable/user-guide/agentchat-user-guide/graph-flow.html)
- [AutoGen Teams and Multi-Agent Patterns](https://microsoft.github.io/autogen/stable/user-guide/agentchat-user-guide/tutorial/teams.html)
- Azure OpenAI API documentation and enterprise features
- FastAPI 0.115.12 WebSocket implementation guides
- Next.js 15 App Router and React 19 migration guides
- shadcn/ui component library and customization patterns

## Installation Commands
```bash
# Install AutoGen AgentChat with GraphFlow support (add to existing project)
uv add "autogen-agentchat"

# Install OpenAI integration (add to existing project)
uv add "autogen-ext[openai]"

# Note: FastAPI backend and Next.js/shadcn/ui frontend boilerplate already provided
# Note: Azure OpenAI configuration already set up in .env file
```

## GraphFlow Implementation Example
```python
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.teams import DiGraphBuilder, GraphFlow
from autogen_ext.models.openai import OpenAIChatCompletionClient

# Create agents
assessor = AssistantAgent("assessor", model_client=client, 
                         system_message="Analyze insurance claims for approval/rejection")
communicator = AssistantAgent("communicator", model_client=client,
                             system_message="Draft customer communications")

# Build workflow graph
builder = DiGraphBuilder()
builder.add_node(assessor).add_node(communicator)
builder.add_edge(assessor, communicator)  # Sequential: assess then communicate

# Create and run workflow
flow = GraphFlow([assessor, communicator], graph=builder.build())
stream = flow.run_stream(task="Process insurance claim #12345")
```
</PRD> 